# Решение задачи динамического программирования  
**Тема:** пошаговое управление инвестиционным портфелем

---

## 1. Цель работы и постановка задачи

**Цель работы** – познакомиться с методом динамического программирования при принятии решений в условиях неопределённости и применить его к задаче управления инвестиционным портфелем по критерию Байеса (максимальное математическое ожидание дохода).

**Сюжет задачи.**

У инвестора есть три инструмента:

- ЦБ1 – первая ценная бумага;
- ЦБ2 – вторая ценная бумага;
- Деп. – банковский депозит.

К началу планового периода структура капитала (в денежном эквиваленте) такова:

- ЦБ1 – 100 д.е.;  
- ЦБ2 – 800 д.е.;  
- Деп. – 400 д.е.;  
- свободные средства – 600 д.е.

Общий начальный капитал:

\[
X_0 = 100 + 800 + 400 + 600 = 1900 \text{ д.е.}
\]

Период планирования разбит на три этапа (квартала).  
На каждом этапе возможно одно из состояний экономики:

- благоприятное;
- нейтральное;
- негативное.

Для каждого этапа заданы:

- вероятности состояний;
- коэффициенты изменения стоимости активов (во сколько раз умножается вложенная сумма).

Задача: **разработать план управления портфелем на 3 этапа**, то есть на каждом этапе выбрать один из трёх инструментов для вложения всего капитала, чтобы **максимизировать ожидаемый итоговый капитал**.

---

## 2. Общая математическая формулировка задачи динамического программирования

Рассмотрим общую постановку задачи динамического программирования в дискретном времени.

- \(t = 1, \dots, T\) – номер этапа;
- \(x_t\) – состояние системы на этапе \(t\);
- \(u_t\) – управлене (решение) на этапе \(t\);
- \(\xi_t\) – случайное воздействие (состояние среды) на этапе \(t\);
- \(f_t(x_t, u_t, \xi_t)\) – функция перехода: задаёт состояние \(x_{t+1}\);
- \(g_t(x_t, u_t, \xi_t)\) – прибыль/затраты на этапе \(t\);
- \(\Phi(x_{T+1})\) – терминальная прибыль.

Цель – максимизировать математическое ожидание суммарной прибыли:

\[
J = \mathbb{E}\left[ \sum_{t=1}^{T} g_t(x_t, u_t, \xi_t) + \Phi(x_{T+1}) \right]
\to \max_{u_1,\dots,u_T}.
\]

Введём **функцию ценности (value function)**:

\[
V_t(x) = \max_{u_t,\dots,u_T} 
\mathbb{E}\left[\sum_{k=t}^{T} g_k(x_k, u_k, \xi_k) + \Phi(x_{T+1}) \,\middle|\, x_t = x \right].
\]

### Уравнение Беллмана (общий вид)

Базовое условие:

\[
V_{T+1}(x) = \Phi(x).
\]

Рекуррентное соотношение Беллмана:

\[
V_t(x) = \max_{u} \mathbb{E}_{\xi_t}
\bigl[ g_t(x, u, \xi_t) + V_{t+1}(f_t(x, u, \xi_t)) \bigr].
\]

Это уравнение позволяет вычислять \(V_t(x)\) **обратным ходом** – от последнего этапа к первому.

---

## 3. Рекуррентное соотношение Беллмана и схема решения

### Обозначения в общем случае

- \(V_t(x)\) – максимальное ожидаемое значение целевой функции, начиная с этапа \(t\) при состоянии \(x\);
- \(u_t^*(x)\) – оптимальное управление на этапе \(t\) в состоянии \(x\).

### Формула Беллмана

Ещё раз в компактной форме:

\[
V_t(x) = \max_{u \in U_t(x)} 
\mathbb{E}\bigl[ g_t(x,u,\xi_t) + V_{t+1}(f_t(x,u,\xi_t)) \bigr].
\]

### Обратный и прямой проход

- **Обратный проход (backward induction)**  
  1. Задаём терминальное условие \(V_{T+1}(x)\).  
  2. Для \(t = T, T-1, \dots, 1\) и всех возможных состояний \(x\) вычисляем \(V_t(x)\) по формуле Беллмана.  
  3. Одновременно запоминаем оптимальные управления \(u_t^*(x)\).

- **Прямой проход (forward)**  
  Зная стратегию \(u_t^*(x)\) и стартовое состояние \(x_1\), можно пройти этапы вперёд, симулируя работу системы и получая траекторию состояний и значений целевой функции.

---

## 4. Конкретная постановка задачи и рекуррентное соотношение

### Обозначения

- \(t = 1, 2, 3\) – номер этапа (квартал);
- \(X_t\) – капитал в начале этапа \(t\);
- \(u_t \in \{\text{CB1}, \text{CB2}, \text{DEP}\}\) – выбранный актив на этапе \(t\);
- \(\xi_t \in \{\text{благоприятное}, \text{нейтральное}, \text{негативное}\}\) – состояние экономики на этапе \(t\).

Таблица вероятностей (по условию):

| Этап | p(Благопр.) | p(Нейтр.) | p(Негатив.) |
|------|-------------|-----------|-------------|
| 1    | 0.60        | 0.30      | 0.10        |
| 2    | 0.30        | 0.20      | 0.50        |
| 3    | 0.40        | 0.40      | 0.20        |

Таблица коэффициентов изменения стоимости активов \(a_{t,i}(\xi_t)\):

| Ситуация | Вероят. | **Этап 1** ЦБ1 | ЦБ2 | Деп. | Вероят. | **Этап 2** ЦБ1 | ЦБ2 | Деп. | Вероят. | **Этап 3** ЦБ1 | ЦБ2 | Деп. |
|----------|---------|----------------|-----|------|---------|----------------|-----|------|---------|----------------|-----|------|
| Бл.      | 0.60    | 1.20           | 1.10| 1.07 | 0.30    | 1.40           | 1.15| 1.01 | 0.40    | 1.15           | 1.12| 1.05 |
| Нейтр.   | 0.30    | 1.05           | 1.02| 1.03 | 0.20    | 1.05           | 1.00| 1.00 | 0.40    | 1.05           | 1.01| 1.01 |
| Нег.     | 0.10    | 0.80           | 0.95| 1.00 | 0.50    | 0.60           | 0.90| 1.00 | 0.20    | 0.70           | 0.94| 1.00 |

### Динамика капитала

Если на этапе \(t\) мы вкладываем весь капитал \(X_t\) в актив \(u_t\), то после реализации состояния экономики \(\xi_t\) капитал в конце этапа:

\[
X_{t+1} = X_t \cdot a_{t, u_t}(\xi_t).
\]

Начальное условие: \(X_1 = X_0 = 1900\) д.е.

### Целевая функция (критерий Байеса)

Итоговый капитал после 3 этапов:

\[
X_4 = X_1 \cdot a_{1,u_1}(\xi_1)\, a_{2,u_2}(\xi_2)\, a_{3,u_3}(\xi_3).
\]

Нужно максимизировать **математическое ожидание**:

\[
\mathbb{E}[X_4] \to \max_{u_1,u_2,u_3}.
\]

### Ожидаемые мультипликаторы

Для каждого этапа \(t\) и актива \(i\) вводим:

\[
\mu_{t,i} = \mathbb{E}[a_{t,i}(\xi_t)] =
\sum_{s} p_t(s)\, a_{t,i}(s).
\]

Расчёт даёт:

| Этап | μ(ЦБ1) | μ(ЦБ2) | μ(Деп.) |
|------|--------|--------|---------|
| 1    | 1.115  | 1.061  | 1.051   |
| 2    | 0.930  | 0.995  | 1.003   |
| 3    | 1.020  | 1.040  | 1.024   |

### Рекуррентное соотношение Беллмана для задачи

Поскольку прибыль зависит только от итогового капитала, удобно рассматривать функцию:

\[
V_t(x) = \max_{u_t,\dots,u_3} \mathbb{E}[X_4 \mid X_t = x].
\]

Для нашей модели выполняется линейность:

\[
V_t(x) = k_t \cdot x,
\]

где \(k_t\) – коэффициент, зависящий только от этапа.

Подставляя в уравнение Беллмана, получаем:

\[
k_t = k_{t+1} \cdot \max_{i} \mu_{t,i}, \quad k_4 = 1.
\]

Отсюда:

- \(k_3 = 1 \cdot \max_i \mu_{3,i} = 1.04\);  
- \(k_2 = k_3 \cdot \max_i \mu_{2,i} \approx 1.04 \cdot 1.003 = 1.04312\);  
- \(k_1 = k_2 \cdot \max_i \mu_{1,i} \approx 1.04312 \cdot 1.115 \approx 1.1631.\)

Оптимальный ожидаемый итоговый капитал:

\[
\mathbb{E}[X_4] = V_1(X_0) = k_1 \cdot X_0 \approx 1.1631 \cdot 1900 \approx 2209{,}9 \text{ д.е.}
\]

### Оптимальная стратегия

Из таблицы \(\mu_{t,i}\) видно, какие активы дают наибольший ожидаемый коэффициент:

- этап 1 – **ЦБ1**;  
- этап 2 – **депозит**;  
- этап 3 – **ЦБ2**.

То есть оптимальный план:  
**(ЦБ1 → Депозит → ЦБ2)**.

---

## 5. Псевдокод основного алгоритма

Ниже приведён псевдокод, реализующий описанный выше алгоритм динамического программирования.

```text
Вход:
  X0       – начальный капитал
  p[t][s]  – вероятности состояний s на этапе t
  a[t][asset][s] – коэффициенты доходности

1. Для каждого t = 1..3 и актива asset:
       mu[t][asset] = Σ_s p[t][s] * a[t][asset][s]

2. best_factor[4] = 1        // k4 = 1, терминальное условие
   Для t = 3, 2, 1 (обратный ход):
       Для каждого asset:
           candidate[asset] = mu[t][asset] * best_factor[t + 1]
       Выбрать asset* с максимальным candidate[asset]
       best_factor[t] = candidate[asset*]   // k_t
       best_asset[t]  = asset*              // оптимальный актив на этапе t

3. Ожидаемый итоговый капитал:
       E_X4 = best_factor[1] * X0

Выход:
  best_asset[1..3]  – оптимальный план инвестиций
  E_X4              – максимальное математическое ожидание итогового капитала
```
Реализация псевдокода выполнена на языке Python в виде простого скрипта (один модуль без сложной структуры классов).

## 6. Демонстрационный вариант программы
При запуске скрипта выводится следующая информация:

## 7. Демонстрационные примеры программы

При запуске скрипта выводится:

- таблица ожидаемых мультипликаторов `μ_{t,i}` для каждого этапа и актива;
- коэффициенты `k_t` в соотношении `V_t(x) = k_t · x`;
- оптимальный выбор актива на каждом этапе;
- начальный капитал, ожидаемый итоговый капитал и ожидаемый доход.

Пример фрагмента вывода программы (значения округлены):

```text
Ожидаемые мультипликаторы μ_{t,i}:
{1: {'CB1': 1.115, 'CB2': 1.061, 'DEP': 1.051},
 2: {'CB1': 0.9299999999999999, 'CB2': 0.995, 'DEP': 1.0030000000000001},
 3: {'CB1': 1.02, 'CB2': 1.04, 'DEP': 1.024}}

Коэффициенты k_t (V_t(x) = k_t * x):
{1: 1.1630788, 2: 1.04312, 3: 1.04, 4: 1.0}

Оптимальный актив на каждом этапе:
Этап 1: вложить капитал в CB1
Этап 2: вложить капитал в DEP
Этап 3: вложить капитал в CB2

Начальный капитал: 1900.00
Ожидаемый капитал после 3-го этапа: 2209.85
Ожидаемый доход: 309.85
```

## 8. Выводы

В данной работе:

- Рассмотрена общая постановка задач динамического программирования;

- Записано уравнение Беллмана и схема обратного/прямого прохода;

- Сформулирована конкретная задача управления инвестиционным портфелем в условиях неопределённости;

- Для каждого этапа и актива вычислены ожидаемые мультипликаторы доходности;

- С использованием критерия Байеса найдена оптимальная стратегия инвестирования:
1-й этап — ЦБ1, 2-й этап — депозит, 3-й этап — ЦБ2;

- Реализован скрипт на Python, подтверждающий полученные теоретические результаты.

В результате работы удалось на практике применить метод динамического программирования
к экономической задаче и закрепить понимание принципа оптимальности Беллмана.